%---------
% place your email id between the braces so that your homework has a name
\def\yourname{}
% -----------------------------------------------------
\def\duedate{3/29/24}
\def\duelocation{via \href{https://www.gradescope.com/courses/753885}{Gradescope}}
\def\hnumber{2}
\def\prof{Lorenzo Orecchia}
\def\course{\href{https://canvas.uchicago.edu/courses/56880}{CMSC 27200 - Spring 2024}}
%-------------------------------------

\documentclass[10pt]{article}
\usepackage[colorlinks,urlcolor=blue]{hyperref}
\usepackage[osf]{mathpazo}
\usepackage{amsmath,amsfonts,graphicx}
\usepackage{latexsym}
\usepackage{subfig}
\usepackage{algpseudocode}
\usepackage[shortlabels]{enumitem}
\usepackage{algorithm}
\usepackage{listings}
\usepackage{multirow}
\usepackage{diagbox}
\usepackage{makecell}
%\usepackage[top=1in,bottom=1.4in,left=1.5in,right=1.5in,centering]{geometry}
\usepackage{fullpage}
\usepackage{color}
\definecolor{mdb}{rgb}{0.3,0.02,0.02} 
\definecolor{cit}{rgb}{0.05,0.2,0.45} 
%\pagestyle{myheadings}
\markboth{\yourname}{\yourname}

\thispagestyle{empty}

\newenvironment{proof}{\par\noindent{\it Proof.}\hspace*{1em}}{$\Box$\bigskip}
\newcommand{\qed}{$\Box$}
\newcommand{\alg}[1]{\mathsf{#1}}
\newcommand{\handout}{
   \renewcommand{\thepage}{H\hnumber-\arabic{page}}
   \noindent
   \begin{center}
      \vbox{
    \hbox to \columnwidth {\sc{\course} --- \prof \hfill}
    \vspace{-2mm}
    \hbox to \columnwidth {\sc due \MakeLowercase{\duedate} \duelocation\hfill {\Huge\color{mdb}H\hnumber.\yourname}}
      }
   \end{center}
   \vspace*{2mm}
}
\newcommand{\solution}[1]{
\vspace{2mm}

\noindent Collaborators:

\vspace{5mm}

\medskip\noindent{\color{cit}\textbf{Solution:} #1}}

\newcommand{\bit}[1]{\{0,1\}^{ #1 }}
\newcommand{\extraspace}{\medskip\noindent{\color{cit} Extra space for your solution}\newpage}
%\dontprintsemicolon
%\linesnumbered
\newtheorem{problem}{\sc\color{cit}Problem}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{claim}{Claim}


\begin{document}
\handout
\begin{itemize}

\item The assignment is due at Gradescope on \duedate.

\item A LaTeX template will be provided for each homework. You are strongly encouraged to type your homework into this template using \LaTeX.  If you are writing by hand, please fill in the solutions in this template, inserting additional sheets as necessary. This will help facilitate the grading.

\item You are permitted to discuss the problems with up to 2 other students in the class (per problem); however, {\em you must write up your own solutions, in your own words}. Do not submit anything you cannot explain. If you do collaborate with any of the other students on any problem, please list all your collaborators in the appropriate spaces.

\item Similarly, please list any other source you have used for each problem, including other textbooks or websites.

\item {\em Show your work.} Answers without justification will be given little credit.

\item Your homework is \textit{resubmittable}. Please refer to the course syllabus on Canvas for a more detailed description of this. For any problem that you have not changed from your last submission, please make sure to indicate this in your submission to help our graders grade faster. 

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem} Consider the recursive version of the gcd algorithm given in class and in the DPV textbook. 

\begin{enumerate}
    \item How much space, i.e., memory allocation, does this algorithm require as stated?
    \item Write pseudocode for an iterative version of the algorithm that reduces the space requirement to $O(n)$ bits.
    \end{enumerate}
\end{problem}
\solution{
 \begin{enumerate}
    \item The recursive version of the gcd algorithm requires $O(n)$ space, where $n$ is the number of recursive calls the algorithm makes.
    \item \indent The algorithm is as follows:
    \begin{algorithm}
            \caption{Iterative GCD Algorithm} 
            \begin{algorithmic}[1]
            \Statex \textbf{Input:} Two numbers $a$ and $b$ with $a > b \geq 0$
            \Statex \textbf{Output:} The greatest common divisor (gcd) of $a$ and $b$

            \State while $b \neq 0$:
            \State \indent$temp = b$
            \State \indent$b = a \mod b$
            \State \indent$a = temp$
            \State end while
                \State \textbf{Return} $a$
            \end{algorithmic}
        \end{algorithm}

        This algorithm uses a constant amount of space, $O(1)$ space complexity, which is O(n) bits.
 \end{enumerate}
}
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem}
Let $F_i$ be the $i$th Fibonacci number.  Consider the execution of the recursive $\gcd$ algorithm on inputs $(a,b)$ with $a > b \geq 0.$ Show that if $b \leq F_{k}$ for some $k$, then the algorithm makes at most $k$ recursive calls.
\end{problem}
\solution{
 Let's prove this by induction
    \begin{proof}

    \textbf{Base Case:} For $k = 0$, we have $F_0 = 0$. If $b \leq 0$, then the algorithm will terminate immediately without making any calls. For $k = 1$, we have $F_1 = 1$. If $b \leq F_1 =  1$, so base cases hold. \\

    \textbf{Inductive Hypothesis:} Assume that the statement holds for $k \geq 1$ such that if $b \leq F_k$, then the algorithm makes at most $k$ recursive calls. We need to show it holds for $k+1$.\
        \begin{enumerate}
            \item If $b \leq F_k$, then the algorithm makes at most $k$ recursive calls by our hypothesis.
            \item If $ F_k < b \leq F_{k+1}$, then the algorithm will make a recursive call with $a = b$ and $b = a \mod b < F_k$. Thus, the algorithm will make at most $k$ recursive calls by our hypothesis. Since the initial call is not counted, the total number of recursive calls is at most $k+1$.
        \end{enumerate}
        In both cases, the algorithm makes at most $k+1$ recursive calls. Therefore, by induction, the statement holds for all $k \geq 0$.
    \end{proof}
    }
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}[Programming: Probabilistic Testing and Primality]

Follow this \href{https://colab.research.google.com/drive/1J1VbRDhsAPRtdg48Xd5mBn1SsuQSFgLl?usp=sharing}{Google Colab template link} to implement Fermat primality testing. \textbf{Do not attempt to edit the linked file. Create your own copy instead by clicking File $\rightarrow$ Save a copy in Drive}. When you have completed it, download it as a Jupyter Notebook and submit it to the appropriate Gradescope assignment. 
\end{problem}
\solution{\href{https://colab.research.google.com/drive/19P87kpckHuO5x1bWorj-lXW3D9QobLZq?usp=sharing}{Click Here}}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
Wilson’s theorem says that a number N is prime if and only if 
\[
    (N-1)!\equiv -1 (\operatorname{mod} N).
\]
In this problem, we will walk through writing a formal proof for this theorem. 
\begin{enumerate}
    \item[(a)] We can prove Wilson's Theorem by proving three lemmas:
    \lemma{If $p$ is prime, only $1$ and $p-1$ are their own inverses modulo $p$.}
    \lemma{If $p$ is prime, $(p - 1)! \equiv -1 (\operatorname{mod} p)$.}
    \lemma{?????}
    
    What is the third lemma that needs to be proven for a complete proof of Wilson's Theorem?
    
    \item[(b)] Provide a proof of Lemma 1. You may use the fact that if $p$ is prime, then we know every number $1 \leq x < p$ is invertible modulo $p$.

    \item[(c)] Provide a proof of Lemma 2 by pairing up multiplicative inverses. You may use the fact that every number $1 \leq x < p$ has a \textbf{unique} inverse modulo $p$. 
    
    \item[(d)] Provide a proof of Lemma 3. (Hint: Note that this can only happen if: 
    \[
        \operatorname{gcd}(N, (N - 1)!) = 1.
    \]
    )

    \item[(e)] We've just shown that Wilson’s theorem is an if-and-only-if condition for primality. Why can't we base a primality test algorithm on Wilson's Theorem? 
\end{enumerate}

\end{problem}

\solution{
    \begin{enumerate}[(a)]
        \item if $N$ is composite, then $(N-1)! \not\equiv -1 (\operatorname{mod} N)$.
        \item For any prime $p$, every number $1 \leq x < p$ is invertible modulo $p$. This implies that for each $x$ in the range $1 \leq x < p$, there exists a unique $x^{-1}$ such that $x\cdot x^{-1} \equiv 1 (\operatorname{mod} p)$.
        The numbers that are their own inverses are $1$ and $p-1$. Only these two numbers satisfy $x \cdot x^{-1} \equiv 1 (\operatorname{mod} p)$ as if other number does, then it implies that $p$ divides either $x-1$ or $x+1$.
        \item For any prime $p$, according to Lemma 1, each number 2 through $p-2$ is invertable modulo $p$. Pairing up these inverses with each number in $(p-1)!$, 
        we get that the product of all numbers from 2 through $p-2$ is congruent to 1 modulo $p$ as $x\cdot x^{-1} \equiv 1 (\operatorname{mod} p)$. This implies that $(p-1)!
         \equiv -1 (\operatorname{mod} p)$.
        \item Assume that $N$ is composite. Then, $N$ has a factor $d$ such that $1< d < N$. Since $d$divides $N$, it also divides $(N-1)!$ as the product of $(N-1)!$ contains $N$. Therefore, $\operatorname{gcd}(N, (N-1)!) \neq 1$. This implies that if $N$ is composite, then $(N-1)! \not\equiv -1 (\operatorname{mod} N)$.
        \item This is because the theorem is computationally inefficient. Calculating $(N-1)!$ modulo $N$ needs to deal with $O(n)$ multiplications and also very large intermediate product, 
        which significantly increases the time complexity that grows extremely rapidly in a way that is much faster than expotential functions. 
        Thus, the primality test is not practical for large $N$.
    \end{enumerate}
}



\end{document}
